// This file is auto-generated by @hey-api/openapi-ts

/**
 * Error response payload.
 */
export type _Error = {
    /**
     * - ERR_ACCESS_DENIED: Access denied. Usually that error can occur when the user is not authorized to perform the operation (e.g. buyer tries to remove admin or buyer tries to add a new user). Mostly theoretical error.
     * - ERR_ALREADY_EXISTS: The record already exists in the system. Usually that error can occur during adding users, that were already added to the system.
     * - ERR_ALREADY_VERIFIED: The request was already verified. Usually that error can occur during verification of the code, that was already verified.
     * - ERR_AUTH_CODE_INVALID: The provided auth code is invalid. Usually that error can occur during verification of the auth code, that is invalid.
     * - ERR_INSUFFICIENT_FUNDS: Insufficient funds. Usually that error can occur during moving (transferring, withdrawing) funds from the account or card, when the source doesn't have enough of funds.
     * - ERR_INTERNAL: Internal server error. Usually that error indicates some general internal server error, that has nothing to do with client's data, so it can be used with 500 http code.
     * - ERR_INVALID_ARG: Invalid argument(s) was (were) provided during the request. Usually that error can occur when one or more arguments (or their combination) were provided in incorrect format or the operation with the given arguments is prohibited (e.g. you can't delete the general account). Usually that error could be eliminated by calling another endpoint in advance, that provides correct values (or options) to call the former endpoint.
     * - ERR_INVALID_CREDENTIALS: Invalid credentials were provided during the request. Usually that error can occur during providing invalid password and/or email.
     * - ERR_NOT_FOUND: The resource was not found. Usually that error can occur during requesting the resource, that was already removed and can't be accessed anymore (e.g. requesting deleted transaction/user/account information).
     * - ERR_WEAK_PASSWORD: Weak password. Usually that error can occur during providing too weak password for sign up or update password processes. That error should not be the case for web clients, since the password weakness is validated on the FE, so if you encountered that error, probably the FE and the BE are not aligned properly with each other.
     * - ERR_CONTACT_SUPPORT: Some error occurred that needs to be escalated to support. That might signal that liquidity is low.
     * - ERR_SELF_TRANSFER: It is not allowed to transfer funds from an account to itself.
     *
     */
    code: 'ERR_ACCESS_DENIED' | 'ERR_ALREADY_EXISTS' | 'ERR_ALREADY_VERIFIED' | 'ERR_AUTH_CODE_INVALID' | 'ERR_INSUFFICIENT_FUNDS' | 'ERR_INTERNAL' | 'ERR_INVALID_ARG' | 'ERR_INVALID_CREDENTIALS' | 'ERR_NOT_FOUND' | 'ERR_WEAK_PASSWORD' | 'ERR_CONTACT_SUPPORT' | 'ERR_SELF_TRANSFER';
    /**
     * Human-readable error message
     */
    message?: string;
    /**
     * Additional error details
     */
    details?: {
        [key: string]: unknown;
    };
    /**
     * Error occurrence timestamp
     */
    timestamp?: string;
};

/**
 * Email address
 */
export type Email = string;

/**
 * Password (minimum 8 characters)
 */
export type Password = string;

/**
 * Request payload for user authentication
 */
export type AuthRequestPayload = {
    email: Email;
    password: Password;
    /**
     * Extend token expiration
     */
    isRememberMe?: boolean;
};

/**
 * Authentication token response
 */
export type TokenResponse = {
    /**
     * JWT access token
     */
    accessToken: string;
    /**
     * JWT refresh token
     */
    refreshToken: string;
    /**
     * Access token expiration time in seconds
     */
    accessTokenExpiresInSeconds: number;
    /**
     * Refresh token expiration time in seconds
     */
    refreshTokenExpiresInSeconds: number;
};

/**
 * Unique identifier
 */
export type Id = string;

/**
 * Name (either first name or last name) of the user.
 */
export type Name = string;

/**
 * Profile role.
 */
export type UserRole = 'ADMIN' | 'BUYER' | 'TEAM_LEAD';

/**
 * User status.
 * - ACTIVE: The user is currently active and operational.
 * - PENDING: User has been invited but not yet activated by the user.
 * - FROZEN: The user is inactive and not available for transactions.
 * - DELETED: The user has been deleted and is no longer active.
 *
 */
export type UserStatus = 'ACTIVE' | 'PENDING' | 'FROZEN' | 'DELETED';

/**
 * User avatar URL
 */
export type AvatarUrl = string | null;

/**
 * User entity representing a system user
 */
export type User = {
    id: Id;
    email: Email;
    firstName: Name;
    lastName: Name;
    role: UserRole;
    status: UserStatus;
    avatarUrl?: AvatarUrl;
    /**
     * Creation timestamp
     */
    createdAt: string;
    /**
     * Last update timestamp
     */
    updatedAt: string;
    /**
     * Last login timestamp
     */
    lastLoginAt?: string | null;
};

/**
 * Request payload for user registration
 */
export type RegisterRequestPayload = {
    email: Email;
    password: Password;
    firstName: Name;
    lastName: Name;
};

/**
 * Request payload for refreshing authentication tokens
 */
export type AuthTokenRefreshRequestPayload = {
    /**
     * JWT refresh token
     */
    refreshToken: string;
};

/**
 * Limit of records count to return.
 */
export type Limit = number;

/**
 * Offset of records to skip.
 */
export type PaginationOffset = number;

/**
 * Enum defining the fields by which user can sort the users list.
 */
export type UserSortField = 'FULL_NAME';

/**
 * Enum for sorting order.
 */
export type Order = 'ASC' | 'DESC';

/**
 * Order of sorting (ascending/descending). `sortBy` and `orderBy` arrays have always the same length, and each element or `sortBy` array corresponds to the appropriate element of `orderBy` array.
 */
export type OrderBy = Array<Order>;

/**
 * Pagination metadata for list responses
 */
export type PaginationMeta = {
    /**
     * Number of items per page
     */
    limit: number;
    /**
     * Offset of records to skip
     */
    offset: number;
    /**
     * Total number of items
     */
    total: number;
};

/**
 * Request payload for creating a new user
 */
export type UserCreateRequest = {
    email: Email;
    firstName: Name;
    lastName: Name;
    password: Password;
    role?: UserRole;
    status?: UserStatus;
};

/**
 * Request payload for updating user information
 */
export type UserUpdateRequest = {
    firstName?: Name;
    lastName?: Name;
    role?: UserRole;
    status?: UserStatus;
    avatarUrl?: AvatarUrl;
};

/**
 * Request payload for updating user email
 */
export type UserUpdateEmailRequest = {
    newEmail: Email;
    password: Password;
};

/**
 * Users request payload.
 */
export type UsersRequestPayload = {
    limit: Limit;
    offset: PaginationOffset;
    /**
     * Filter criteria for selecting records.
     */
    filter?: {
        /**
         * Full text search.
         */
        text?: string;
        /**
         * Filter by user statuses.
         */
        statuses?: Array<UserStatus>;
        /**
         * Filter by user roles.
         */
        roles?: Array<UserRole>;
    };
    /**
     * Fields to sort the results by.
     */
    sortBy?: Array<UserSortField>;
    orderBy?: OrderBy;
};

/**
 * User unique identifier
 */
export type UserId = string;

export type GetHealthStatusData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/health';
};

export type GetHealthStatusErrors = {
    /**
     * Internal server error
     */
    500: _Error;
};

export type GetHealthStatusError = GetHealthStatusErrors[keyof GetHealthStatusErrors];

export type GetHealthStatusResponses = {
    /**
     * Service is healthy
     */
    200: {
        status?: string;
        timestamp?: string;
        version?: string;
    };
};

export type GetHealthStatusResponse = GetHealthStatusResponses[keyof GetHealthStatusResponses];

export type AuthenticateUserData = {
    body: AuthRequestPayload;
    path?: never;
    query?: never;
    url: '/v1/auth/login';
};

export type AuthenticateUserErrors = {
    /**
     * Invalid request
     */
    400: _Error;
    /**
     * Invalid credentials
     */
    401: _Error;
};

export type AuthenticateUserError = AuthenticateUserErrors[keyof AuthenticateUserErrors];

export type AuthenticateUserResponses = {
    /**
     * Login successful
     */
    200: TokenResponse & {
        user: User;
    };
};

export type AuthenticateUserResponse = AuthenticateUserResponses[keyof AuthenticateUserResponses];

export type RegisterUserData = {
    body: RegisterRequestPayload;
    path?: never;
    query?: never;
    url: '/v1/auth/register';
};

export type RegisterUserErrors = {
    /**
     * Invalid request
     */
    400: _Error;
    /**
     * User already exists
     */
    409: _Error;
};

export type RegisterUserError = RegisterUserErrors[keyof RegisterUserErrors];

export type RegisterUserResponses = {
    /**
     * User registered successfully
     */
    201: TokenResponse & {
        user: User;
    };
};

export type RegisterUserResponse = RegisterUserResponses[keyof RegisterUserResponses];

export type RefreshTokensData = {
    body: AuthTokenRefreshRequestPayload;
    path?: never;
    query?: never;
    url: '/v1/auth/refresh';
};

export type RefreshTokensErrors = {
    /**
     * Invalid request
     */
    400: _Error;
    /**
     * Invalid refresh token
     */
    401: _Error;
};

export type RefreshTokensError = RefreshTokensErrors[keyof RefreshTokensErrors];

export type RefreshTokensResponses = {
    /**
     * Token refreshed successfully
     */
    200: TokenResponse;
};

export type RefreshTokensResponse = RefreshTokensResponses[keyof RefreshTokensResponses];

export type LogoutUserData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/auth/logout';
};

export type LogoutUserErrors = {
    /**
     * Unauthorized
     */
    401: _Error;
};

export type LogoutUserError = LogoutUserErrors[keyof LogoutUserErrors];

export type LogoutUserResponses = {
    /**
     * Logout successful
     */
    200: {
        success?: boolean;
    };
};

export type LogoutUserResponse = LogoutUserResponses[keyof LogoutUserResponses];

export type GetUserListData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Users request payload.
         */
        UsersRequestPayload: {
            limit: Limit;
            offset: PaginationOffset;
            /**
             * Filter criteria for selecting records.
             */
            filter?: {
                /**
                 * Full text search.
                 */
                text?: string;
                /**
                 * Filter by user statuses.
                 */
                statuses?: Array<UserStatus>;
                /**
                 * Filter by user roles.
                 */
                roles?: Array<UserRole>;
            };
            /**
             * Fields to sort the results by.
             */
            sortBy?: Array<UserSortField>;
            orderBy?: OrderBy;
        };
    };
    url: '/v1/users';
};

export type GetUserListErrors = {
    /**
     * Invalid request.
     */
    400: _Error;
    /**
     * Unauthorized.
     */
    401: _Error;
};

export type GetUserListError = GetUserListErrors[keyof GetUserListErrors];

export type GetUserListResponses = {
    /**
     * Successful retrieval of users.
     */
    200: {
        data?: Array<User>;
        meta?: PaginationMeta;
    };
};

export type GetUserListResponse = GetUserListResponses[keyof GetUserListResponses];

export type CreateUserData = {
    body: UserCreateRequest;
    path?: never;
    query?: never;
    url: '/v1/users';
};

export type CreateUserErrors = {
    /**
     * Invalid request.
     */
    400: _Error;
    /**
     * Unauthorized.
     */
    401: _Error;
    /**
     * User already exists.
     */
    409: _Error;
};

export type CreateUserError = CreateUserErrors[keyof CreateUserErrors];

export type CreateUserResponses = {
    /**
     * User successfully created. A new user is returned.
     */
    201: User;
};

export type CreateUserResponse = CreateUserResponses[keyof CreateUserResponses];

export type DeleteUserByIdData = {
    body?: never;
    path: {
        /**
         * User unique identifier
         */
        userId: string;
    };
    query?: never;
    url: '/v1/users/{userId}';
};

export type DeleteUserByIdErrors = {
    /**
     * Invalid request.
     */
    400: _Error;
    /**
     * Unauthorized.
     */
    401: _Error;
    /**
     * User not found.
     */
    404: _Error;
};

export type DeleteUserByIdError = DeleteUserByIdErrors[keyof DeleteUserByIdErrors];

export type DeleteUserByIdResponses = {
    /**
     * User deleted successfully
     */
    200: {
        success?: boolean;
    };
};

export type DeleteUserByIdResponse = DeleteUserByIdResponses[keyof DeleteUserByIdResponses];

export type GetUserByIdData = {
    body?: never;
    path: {
        /**
         * User unique identifier
         */
        userId: string;
    };
    query?: never;
    url: '/v1/users/{userId}';
};

export type GetUserByIdErrors = {
    /**
     * Invalid request.
     */
    400: _Error;
    /**
     * Unauthorized.
     */
    401: _Error;
    /**
     * User not found.
     */
    404: _Error;
};

export type GetUserByIdError = GetUserByIdErrors[keyof GetUserByIdErrors];

export type GetUserByIdResponses = {
    /**
     * User retrieved successfully
     */
    200: User;
};

export type GetUserByIdResponse = GetUserByIdResponses[keyof GetUserByIdResponses];

export type UpdateUserByIdData = {
    body: UserUpdateRequest;
    path: {
        /**
         * User unique identifier
         */
        userId: string;
    };
    query?: never;
    url: '/v1/users/{userId}';
};

export type UpdateUserByIdErrors = {
    /**
     * Invalid request.
     */
    400: _Error;
    /**
     * Unauthorized.
     */
    401: _Error;
    /**
     * User not found.
     */
    404: _Error;
};

export type UpdateUserByIdError = UpdateUserByIdErrors[keyof UpdateUserByIdErrors];

export type UpdateUserByIdResponses = {
    /**
     * User updated successfully
     */
    200: User;
};

export type UpdateUserByIdResponse = UpdateUserByIdResponses[keyof UpdateUserByIdResponses];

export type UpdateUserEmailData = {
    body: UserUpdateEmailRequest;
    path: {
        /**
         * User unique identifier
         */
        userId: string;
    };
    query?: never;
    url: '/v1/users/{userId}/email';
};

export type UpdateUserEmailErrors = {
    /**
     * Invalid request
     */
    400: _Error;
    /**
     * Unauthorized
     */
    401: _Error;
    /**
     * Access denied
     */
    403: _Error;
    /**
     * User not found
     */
    404: _Error;
};

export type UpdateUserEmailError = UpdateUserEmailErrors[keyof UpdateUserEmailErrors];

export type UpdateUserEmailResponses = {
    /**
     * User email updated successfully
     */
    200: User;
};

export type UpdateUserEmailResponse = UpdateUserEmailResponses[keyof UpdateUserEmailResponses];

export type ClientOptions = {
    baseUrl: 'https://api.example.com' | 'http://localhost:8080' | (string & {});
};