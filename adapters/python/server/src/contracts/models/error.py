# coding: utf-8

"""
    Contracts Blueprint API

    # Contracts Blueprint API  A simple API blueprint demonstrating enterprise-grade OpenAPI specifications with multi-language code generation support for Go, Python, and TypeScript.  This API provides basic authentication and user management functionality.  ## Features - JWT-based authentication - User CRUD operations - Multi-language SDK generation - Comprehensive error handling  ## Error Codes - `ERR_INTERNAL`: Internal server error - `ERR_INVALID_ARG`: Invalid argument(s) provided - `ERR_NOT_FOUND`: Resource not found - `ERR_ALREADY_EXISTS`: Resource already exists - `ERR_ACCESS_DENIED`: Access denied - `ERR_INVALID_CREDENTIALS`: Invalid authentication credentials - `ERR_VALIDATION_FAILED`: Request validation failed 

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json




from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class Error(BaseModel):
    """
    Error response payload.
    """ # noqa: E501
    code: StrictStr = Field(description="- ERR_ACCESS_DENIED: Access denied. Usually that error can occur when the user is not authorized to perform the operation (e.g. buyer tries to remove admin or buyer tries to add a new user). Mostly theoretical error. - ERR_ALREADY_EXISTS: The record already exists in the system. Usually that error can occur during adding users, that were already added to the system. - ERR_ALREADY_VERIFIED: The request was already verified. Usually that error can occur during verification of the code, that was already verified. - ERR_AUTH_CODE_INVALID: The provided auth code is invalid. Usually that error can occur during verification of the auth code, that is invalid. - ERR_INSUFFICIENT_FUNDS: Insufficient funds. Usually that error can occur during moving (transferring, withdrawing) funds from the account or card, when the source doesn't have enough of funds. - ERR_INTERNAL: Internal server error. Usually that error indicates some general internal server error, that has nothing to do with client's data, so it can be used with 500 http code. - ERR_INVALID_ARG: Invalid argument(s) was (were) provided during the request. Usually that error can occur when one or more arguments (or their combination) were provided in incorrect format or the operation with the given arguments is prohibited (e.g. you can't delete the general account). Usually that error could be eliminated by calling another endpoint in advance, that provides correct values (or options) to call the former endpoint. - ERR_INVALID_CREDENTIALS: Invalid credentials were provided during the request. Usually that error can occur during providing invalid password and/or email. - ERR_NOT_FOUND: The resource was not found. Usually that error can occur during requesting the resource, that was already removed and can't be accessed anymore (e.g. requesting deleted transaction/user/account information). - ERR_WEAK_PASSWORD: Weak password. Usually that error can occur during providing too weak password for sign up or update password processes. That error should not be the case for web clients, since the password weakness is validated on the FE, so if you encountered that error, probably the FE and the BE are not aligned properly with each other. - ERR_CONTACT_SUPPORT: Some error occurred that needs to be escalated to support. That might signal that liquidity is low. - ERR_SELF_TRANSFER: It is not allowed to transfer funds from an account to itself. ")
    message: Optional[StrictStr] = Field(default=None, description="Human-readable error message")
    details: Optional[Dict[str, Any]] = Field(default=None, description="Additional error details")
    timestamp: Optional[datetime] = Field(default=None, description="Error occurrence timestamp")
    __properties: ClassVar[List[str]] = ["code", "message", "details", "timestamp"]

    @field_validator('code')
    def code_validate_enum(cls, value):
        """Validates the enum"""
        if value not in ('ERR_ACCESS_DENIED', 'ERR_ALREADY_EXISTS', 'ERR_ALREADY_VERIFIED', 'ERR_AUTH_CODE_INVALID', 'ERR_INSUFFICIENT_FUNDS', 'ERR_INTERNAL', 'ERR_INVALID_ARG', 'ERR_INVALID_CREDENTIALS', 'ERR_NOT_FOUND', 'ERR_WEAK_PASSWORD', 'ERR_CONTACT_SUPPORT', 'ERR_SELF_TRANSFER',):
            raise ValueError("must be one of enum values ('ERR_ACCESS_DENIED', 'ERR_ALREADY_EXISTS', 'ERR_ALREADY_VERIFIED', 'ERR_AUTH_CODE_INVALID', 'ERR_INSUFFICIENT_FUNDS', 'ERR_INTERNAL', 'ERR_INVALID_ARG', 'ERR_INVALID_CREDENTIALS', 'ERR_NOT_FOUND', 'ERR_WEAK_PASSWORD', 'ERR_CONTACT_SUPPORT', 'ERR_SELF_TRANSFER')")
        return value

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True,
        "protected_namespaces": (),
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of Error from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of Error from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message"),
            "details": obj.get("details"),
            "timestamp": obj.get("timestamp")
        })
        return _obj


